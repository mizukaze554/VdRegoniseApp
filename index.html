<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <title>Multi-FAB Real-Time Object Detection</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: black;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -o-user-select: none;
    }
    #container {
      position: relative;
      height: 70vh;
      max-width: 100vw;
      margin: 2vh auto;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #111;
      border-radius: 12px;
      overflow: hidden;
    }
    video, canvas {
      height: 100%;
      width: auto;
      max-width: 100vw;
      object-fit: cover;
      border-radius: 12px;
      user-select: none;
      -webkit-user-select: none;
    }
    #overlay {
      position: absolute;
      top: 0; left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      user-select: none;
    }

    /* Multiple FAB container */
    #fabContainer {
      position: fixed;
      bottom: 5%;
      right: 5%;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 20;
      user-select: none;
    }

    .fab {
      width: clamp(60px, 15vw, 90px);
      height: clamp(60px, 15vw, 90px);
      font-size: clamp(22px, 6vw, 36px);
      border-radius: 50%;
      box-shadow: 0 8px 15px rgba(0,0,0,0.25);
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    .fab:hover {
      filter: brightness(1.1);
    }
    #fabDetect { background-color: #2563eb; } /* blue */
    #fabSingle { background-color: #16a34a; } /* green */
    #fabSwitch { background-color: #d97706; } /* amber */
    #fabStop   { background-color: #dc2626; } /* red */

    /* Modal backdrop */
    .modal-backdrop {
      background: rgba(0,0,0,0.6);
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      display: flex; justify-content: center; align-items: center;
      z-index: 100;
    }
    /* Modal content */
    .modal-content {
      background: #222;
      color: #eee;
      padding: 1.5rem 2rem;
      border-radius: 0.75rem;
      max-width: 90vw;
      text-align: center;
      font-family: monospace, monospace;
    }
    .modal-content button {
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <!-- Multiple FAB buttons -->
  <div id="fabContainer" aria-label="Camera controls">
    <button id="fabDetect" class="fab" aria-label="Toggle Continuous Detection" title="Toggle Continuous Detection">üîÑ</button>
    <button id="fabSingle" class="fab" aria-label="Single Frame Detect" title="Single Frame Detect">üéØ</button>
    <button id="fabSwitch" class="fab" aria-label="Switch Camera" title="Switch Front/Back Camera">üîÑüì∑</button>
    <button id="fabStop" class="fab" aria-label="Stop Camera" title="Stop Camera Stream">‚èπÔ∏è</button>
  </div>

  <!-- Modals -->
  <div id="infoModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="infoModalTitle">
    <div class="modal-content">
      <h2 id="infoModalTitle" class="text-xl font-bold mb-2">Information</h2>
      <p id="infoModalText">...</p>
      <button id="closeInfoModal" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const fabDetect = document.getElementById('fabDetect');
    const fabSingle = document.getElementById('fabSingle');
    const fabSwitch = document.getElementById('fabSwitch');
    const fabStop = document.getElementById('fabStop');

    const infoModal = document.getElementById('infoModal');
    const infoModalText = document.getElementById('infoModalText');
    const closeInfoModal = document.getElementById('closeInfoModal');

    let model = null;
    let detecting = false;
    let cameraActive = false;
    let facingMode = 'environment';
    let lastTime = 0;
    let frameSkipCount = 0;
    const frameSkipMax = 2; // detect every 3 frames for perf

    // Start camera with facing mode
    async function startCamera() {
      stopCamera();
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode }, audio: false
        }).catch(() => navigator.mediaDevices.getUserMedia({ video: true }));
        video.srcObject = stream;
        await new Promise(r => video.onloadedmetadata = r);
        adjustCanvasSize();
        cameraActive = true;
      } catch (err) {
        showInfo(`Camera error: ${err.message}`);
      }
    }

    function adjustCanvasSize() {
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
      overlay.style.top = video.offsetTop + 'px';
      overlay.style.left = (video.offsetLeft + video.clientWidth / 2) + 'px';
      overlay.style.transform = 'translateX(-50%)';
    }

    // Stop camera
    function stopCamera() {
      if (!cameraActive) return;
      const tracks = video.srcObject?.getTracks?.() || [];
      tracks.forEach(track => track.stop());
      cameraActive = false;
      detecting = false;
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      showInfo('Camera stopped');
    }

    // Draw boxes + labels
    function drawPredictions(predictions) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      predictions.forEach(p => {
        if (p.score < 0.5) return;
        const [x, y, w, h] = p.bbox.map(v => v|0);
        ctx.strokeStyle = '#0FAD4E';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
        ctx.fillStyle = '#0FAD4E';
        ctx.font = `${Math.max(14, overlay.width * 0.02)|0}px sans-serif`;
        ctx.fillText(`${p.class} ${(p.score*100)|0}%`, x, y > 20 ? y - 5 : y + 18);
      });
    }

    // Detect single frame
    async function detectFrame() {
      if (!model || !cameraActive) return;
      const preds = await model.detect(video);
      drawPredictions(preds);
    }

    // Continuous detection loop
    async function detectLoop(time) {
      if (!detecting || !model || !cameraActive) return;
      if (frameSkipCount === 0) {
        const preds = await model.detect(video);
        drawPredictions(preds);
        frameSkipCount = frameSkipMax;
      } else {
        frameSkipCount--;
      }
      const fps = (1000 / (time - lastTime))|0;
      lastTime = time;
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.max(12, overlay.width * 0.015)|0}px monospace`;
      ctx.fillText(`${fps} fps`, 10, 20);
      requestAnimationFrame(detectLoop);
    }

    // Switch camera front/back
    async function switchCamera() {
      facingMode = (facingMode === 'environment') ? 'user' : 'environment';
      await startCamera();
      if (detecting) requestAnimationFrame(detectLoop);
      showInfo(`Switched to ${facingMode === 'environment' ? 'Back' : 'Front'} Camera`);
    }

    // Show info modal
    function showInfo(message) {
      infoModalText.textContent = message;
      infoModal.classList.remove('hidden');
    }

    // Hide info modal
    function hideInfo() {
      infoModal.classList.add('hidden');
    }

    // Button handlers
    fabDetect.onclick = () => {
      detecting = !detecting;
      if (detecting) {
        requestAnimationFrame(detectLoop);
        showInfo('Continuous detection started');
      } else {
        showInfo('Continuous detection stopped');
      }
    };
    fabSingle.onclick = () => {
      detectFrame();
      showInfo('Single frame detection run');
    };
    fabSwitch.onclick = () => switchCamera();
    fabStop.onclick = () => {
      stopCamera();
      showInfo('Camera stopped');
    };

    closeInfoModal.onclick = () => hideInfo();

    // Adjust canvas on resize
    window.addEventListener('resize', () => {
      if (cameraActive) adjustCanvasSize();
    });

    // Initialize on load
    (async () => {
      showInfo('Loading model and starting camera...');
      model = await cocoSsd.load();
      await startCamera();
      detecting = true;
      requestAnimationFrame(detectLoop);
      showInfo('Model loaded and detection started!');
    })();
  </script>
</body>
</html>
