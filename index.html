<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Real‑Time Object Detection (Front/Back Switch)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; overflow: hidden;
      background: black;
    }
    #video, #overlay {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    #fab {
      position: absolute; bottom: 20px; right: 20px;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="overlay"></canvas>
  
  <!-- Floating Action Button -->
  <button id="fab" class="bg-blue-500 hover:bg-blue-600 text-white rounded-full p-4 shadow-lg">
    🎯
  </button>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const fab = document.getElementById('fab');

    let model, detecting = false, cameraActive = false;
    let facingMode = 'environment';
    let lastTap = 0, tapCount = 0;
    let longPressTimer = null;
    let lastTime = 0;

    // 📷 Start camera with given facingMode
    async function startCamera() {
      stopCamera();
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode }, audio: false
        }).catch(() => navigator.mediaDevices.getUserMedia({ video: true }));
        video.srcObject = stream;
        await new Promise(r => video.onloadedmetadata = r);
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
        cameraActive = true;
      } catch (err) {
        alert('Camera error: ' + err.message);
      }
    }

    // 🛑 Stop camera
    function stopCamera() {
      if (!cameraActive) return;
      const tracks = video.srcObject?.getTracks?.() || [];
      tracks.forEach(track => track.stop());
      cameraActive = false;
      detecting = false;
      ctx.clearRect(0, 0, overlay.width, overlay.height);
    }

    // 🔍 Single detection
    async function detectFrame() {
      if (!model || !cameraActive) return;
      const preds = await model.detect(video);
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      preds.forEach(p => {
        if (p.score < 0.5) return;
        const [x, y, w, h] = p.bbox.map(v => v|0); // bitwise truncate
        ctx.strokeStyle = '#0FAD4E';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
        ctx.fillStyle = '#0FAD4E';
        ctx.font = '16px sans-serif';
        ctx.fillText(`${p.class} ${(p.score*100)|0}%`, x, y > 20 ? y - 5 : y + 18);
      });
    }

    // 🔄 Continuous detection loop
    async function detectLoop(time) {
      if (!detecting || !model || !cameraActive) return;
      await detectFrame();
      const fps = (1000 / (time - lastTime))|0;
      lastTime = time;
      ctx.fillStyle = '#fff';
      ctx.font = '14px monospace';
      ctx.fillText(`${fps} fps`, 10, 20);
      requestAnimationFrame(detectLoop);
    }

    // 🔄 Switch camera
    async function switchCamera() {
      facingMode = (facingMode === 'environment') ? 'user' : 'environment';
      await startCamera();
      if (detecting) requestAnimationFrame(detectLoop);
    }

    // 🎛 FAB gesture handling
    fab.addEventListener('click', () => {
      const now = Date.now();
      tapCount++;
      setTimeout(() => tapCount = 0, 400);

      if (tapCount === 1 && now - lastTap > 300) {
        // Single tap = detect one frame
        detectFrame();
      } 
      if (tapCount === 2) {
        // Double tap = toggle detection
        detecting = !detecting;
        if (detecting) requestAnimationFrame(detectLoop);
      }
      if (tapCount === 3) {
        // Triple tap = switch camera
        switchCamera();
        tapCount = 0;
      }
      lastTap = now;
    });

    fab.addEventListener('mousedown', () => {
      longPressTimer = setTimeout(() => stopCamera(), 800);
    });
    fab.addEventListener('mouseup', () => clearTimeout(longPressTimer));
    fab.addEventListener('mouseleave', () => clearTimeout(longPressTimer));

    // 🚀 Init
    (async () => {
      await startCamera();
      model = await cocoSsd.load();
    })();
  </script>
</body>
</html>
